## 51. N-Queens

- [Link to LeetCode](https://leetcode.com/problems/n-queens/)

**Description:**



The **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.

Given an integer `n`, return *all distinct solutions to the **n-queens puzzle***.

Each solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.



<!-- tabs:start -->

### **Example 1:**

![img](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)

```
Input: n = 4
Output: [[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above
```

### **Example 2:**

```
Input: n = 1
Output: [["Q"]]
```

<!-- tabs:end -->



**Constraints:**

- `1 <= n <= 9`



<!-- tabs:start -->

#### **Solution 1**

```java
class Solution {
    private char[][] board;
    private boolean[] cols;
    private boolean[] diag1;
    private boolean[] diag2;
    
    public List<List<String>> solveNQueens(int n) {
        board = new char[n][n];
        for (char[] row : board) {
            Arrays.fill(row, '.');
        }
        cols = new boolean[n];
        diag1 = new boolean[2 * n - 1];
        diag2 = new boolean[2 * n - 1];
        
        List<List<String>> ans = new ArrayList<>();
        nqueens(n, 0, ans);
        return ans;
    }
    
    public void nqueens(int n, int y, List<List<String>> ans) {
        if (y == n) {
            List<String> curr = new ArrayList<>();
            for (char[] row : board) {
                curr.add(new String(row));
            }
            ans.add(curr);
            return;
        }
        
        for (int x = 0; x < n; ++x) {
            if (cols[x] || diag1[x + y] || diag2[x - y + n - 1]) continue;
            cols[x] = diag1[x + y] = diag2[x - y + n - 1] = true;
            board[y][x] = 'Q';
            nqueens(n, y + 1, ans);
            cols[x] = diag1[x + y] = diag2[x - y + n - 1] = false;
            board[y][x] = '.';
        }
    }
}
```

> // DFS W/ Backtracking + Pruning
>
> Time complexity: O(N!)
>
>   放置第 1 个皇后有 N 种可能的方法，放置两个皇后的方法不超过 N (N - 2) ，放置 3 个皇后的方法不超过 N(N - 2)(N - 4) ，以此类推。总体上，时间复杂度为 : O(N!).
>
> Space complexity: O(N)
>
>   需要保存对角线和行的信息。

#### **Solution 2**


```java
// DFS
// Time Complexity: O(n!);
// Space Complexity: O(n)
class Solution {
   private char[][] board;
   private int[] cols, diag1, diag2;
   private List<List<String>> ans;
  
   public List<List<String>> solveNQueens(int n) {
       board = new char[n][n];
       for (char[] row : board)
           Arrays.fill(row, '.');
       cols = new int[n];
       diag1 = new int[2 * n - 1];
       diag2 = new int[2 * n - 1];
       ans = new ArrayList<>();
       nqueens(n, 0);
       return ans;
   }
   private void nqueens(int n, int y) {
       if (y == n) {
           List<String> curr = new ArrayList<>();
           for (char[] row : board)
               curr.add(new String(row));
           ans.add(curr);
           return;
       }
       for (int x = 0; x < n; ++x) {
           if (!available(x, y, n)) continue;
           updateBoard(x, y, n, 1);
           nqueens(n, y + 1);
           updateBoard(x, y, n, 0);
       }
   }
   private boolean available(int x, int y, int n) {
       return cols[x] == 0 && diag1[x + y] == 0 && diag2[x - y + n - 1] == 0;
   }
   private void updateBoard(int x, int y, int n, int isPut) {
       cols[x] = isPut;
       diag1[x + y] = isPut;
       diag2[x - y + n - 1] = isPut;
       board[y][x] = (isPut == 1) ? 'Q' : '.';
   }
}
```



> // DFS W/ Backtracking + Pruning
>
> Time complexity: O(N!)
>
> 放置第 1 个皇后有 N 种可能的方法，放置两个皇后的方法不超过 N (N - 2) ，放置 3 个皇后的方法不超过 N(N - 2)(N - 4) ，以此类推。总体上，时间复杂度为 : O(N!).
>
> Space complexity: O(N)
>
> 需要保存对角线和行的信息。

<!-- tabs:end -->



