# Dynamic Programming

> This part is about **LeetCode** **Dynamic Programming** problems.


## Problem List

* I: O(n), S = O(n), T = O(n)
  * [70. Climbing Stairs](leetcode/dp/70.Climbing-Stairs.md) 

  * [303. Range Sum Query – Immutable](leetcode/dp/303.Range-Sum-Query–Immutable.md)

  * [53. Maximum Subarray](leetcode/dp/53.Maximum-Subarray.md) 
  * [121. Best Time to Buy and Sell Stock](leetcode/dp/121.Best-Time-to-Buy-and-Sell-Stock.md)


* I: O(mn), S = O(mn), T = O(mn)
  * [62. Unique Paths](leetcode/dp/62.Unique-Paths.md) 
  * [63. Unique Paths II](leetcode/dp/63.Unique-Paths-II.md) 
  * [64. Minimum Path Sum](leetcode/dp/64.Minimum-Path-Sum.md) 
  * [120. Triangle](leetcode/dp/120.Triangle.md) 

  * [85. Maximal Rectangle](leetcode/dp/85.Maximal-Rectangle.md) 
  * [221. Maximal Square](leetcode/dp/221.Maximal-Square.md) 
  * [304. Range Sum Query 2D - Immutable](leetcode/dp/304.Range-Sum-Query-2D-Immutable.md) 

  
* I: O(n), S = O(3n), T = O(3n)
  * [198. House Robber](leetcode/dp/198.House-Robber.md) 
  * [213. House Robber II](leetcode/dp/213.House-Robber-II.md) 
  * [309. Best Time to Buy and Sell Stock with Cooldown](leetcode/dp/309.Best-Time-to-Buy-and-Sell-Stock-with-Cooldown.md) 
  * [801. Minimum Swaps To Make Sequences Increasing](leetcode/dp/801.Minimum-Swaps-To-Make-Sequences-Increasing.md) 


* I: O(n), S = O(n), T = O(n\*sqrt(n)) 
  * [279. Perfect Squares](leetcode/dp/279.Perfect-Squares.md)


* I: O(n), S = O(n), T = O(n^2) 
  * [139. Word Break](leetcode/dp/139.Word-Break.md)
  * [140. Word Break II](leetcode/dp/140.Word-Break-II.md)

  * [300. Longest Increasing Subsequence](leetcode/dp/300.Longest-Increasing-Subsequence.md)
  * [1048. Longest String Chain](leetcode/dp/1048.Longest-String-Chain.md)

  * [96. Unique Binary Search Trees](leetcode/dp/96.Unique-Binary-Search-Trees.md)


* I: O(n) + t, S = O(n), T = O(n^2) 


* I: O(n), S = O(2^n), T = O(2^n) 
  * [131. Palindrome Partitioning](leetcode/dp/131.Palindrome-Partitioning.md) (In Search As Well)


* I: O(m + n), S = O(mn), T = O(mn) 
  * [72. Edit Distance](leetcode/dp/72.Edit-Distance.md)
  * [10. Regular Expression Matching](leetcode/dp/10.Regular-Expression-Matching.md)
  * [44. Wildcard Matching](leetcode/dp/44.Wildcard-Matching.md)
  * [97. Interleaving String](leetcode/dp/97.Interleaving-String.md)
  * [115. Distinct Subsequences](leetcode/dp/115.Distinct-Subsequences.md)
  * [1143. Longest Common Subsequence](leetcode/dp/1143.Longest-Common-Subsequence.md)


* I: O(mn), S = O(mn), T = O(mn\*min(n,m))


* I: O(mn) + k, S = O(kmn), T = O(kmn)
  * [688. Knight Probability in Chessboard](leetcode/dp/688.Knight-Probability-in-Chessboard.md)

* I: O(n) + k, S = O(n), T = O(kn)
  * [322. Coin Change](leetcode/dp/322.Coin-Change.md)
  * [1049. Last Stone Weight II](leetcode/dp/1049.Last-Stone-Weight-II.md)


* I: O(n) + k, S = O(n\*k), T = O(kn^2)
  * [410. Split Array Largest Sum](leetcode/dp/410.Split-Array-Largest-Sum.md)


* I: O(n), S = O(n^2), T = O(n^3)
  * [312. Burst Balloons](leetcode/dp/312.Burst-Balloons.md)
  * [1130. Minimum Cost Tree From Leaf Values](leetcode/dp/1130.Minimum-Cost-Tree-From-Leaf-Values.md)


* I: O(n^2), S = O(n^3), T = O(n^3)
  * [741. Cherry Pickup](leetcode/dp/741.Cherry-Pickup.md)


* I: O(n), S = O(n\*2^n), T = (n^2\*2^n)
  * [980. Unique Paths III](leetcode/dp/980.Unique-Paths-III.md)

